pstan反映する事




200606
    PrivateTestTraitTest作成中
    
    外部と内部(domain)の切り分けをよく考える
        Taskとかhttp等は外
        arrayなどdomain内で使い物は内
    
    Domainを中心に、interfaceを考える
        RepositoryInterface
            insert(ModelInterface $domain)
            update(ModelInterface $domain, ModelInterface $where)
            delete(ModelInterface $where)
            
            select()はライブラリの外で拡張?
            getModel()はライブラリの外で拡張?
        
        Service interface
            POST,QUERYは分ける
            http/GETはQUERYをdomainに渡す
            http/CUDはPOSTをdomainに渡す
        
        session,cookie
            cacheと見る
        
    ArrayUtilのmethodを分割したい
        ArrayDotは複数method持つ
        DBを参考にTableのjoin,leftjoin等も1class N個 method
        Pivotは１つだけ
        引数は型の検査を行いたい
        interfaceでmethodを定義しても型が曖昧になる?
            さらに子methodを呼び出す? invoke(){$this->method(array $data)}
        Symfonyはどうやっている?
        JOINのような共通的なmethodはライブラリ内
        projectオリジナルは、生成をサポートするinterface/abstractを用意?
            必要あるのか?
        
    Static methodとinstance method を、どうする?
        Laravelとかinstanceを、どうstatic call?
        
20200613
    ArrayUtil loopを少なくしたい
        DataTableClassを作り、インスタンス化する==>2次元正規テーブルが対象のclass
        現在のpivotなどtranseverseをしない
        methodの最後にexecute()で実際に処理する
        その為には1行の操作と全行の操作との切り分けが必要
        
20200614
    各機能を分離し、変化に耐えられるように考える
        emitter 出力するもの フレームワーク/cliライブラリ
        render  出力に合わせた変換を行う HtmlRender,Jsonrender,PrinterRender,FileRender etc
                    HtmlRender->ignoreEscape([])->execute($viwer)
        viewer  出力のデータ(+加工する処理) XxxHtmlViewerとか出力に応じて分けるかも?
                    viewer->build($domain)
        
        POST/QUERYと同じように出力データの定義＆変換を任せたい==>viewer?
        DOMAINから渡されるデータは、例えばDBからの生データarrayで、ここで変換する？
            数値は桁区切りとか多言語化とかEnum変換とか
        
        DOMAIN=>DBは、RepositoryでMataMapperでデータ型をDBに合わせている
        DB=>DOMAINは、DBのデータ型でデータが渡される
            viewerで出力に合わせたデータ型にする
        
        REQUEST=>DOMAINはどうなる？
            POST/QUERYでValidation,そのままRepositoryに渡しているが・・
            データ型の変換は必要？
            Validationを考えると型変換が欲しい
                DataMapperの型を使いたい==>DataMapperに依存するのは・・
            Validatorを外出し？ persistanceに合わせて作る?
                XxxDbValidator,XxxFileValidator==>無駄だよね
            DataMapperでValidate==>遅い　入口で行いたい
            Validateの定義を、入力に左右されずに定義できるか？
                POST/QUERYで型変換？、Validate？
            VOで渡す？
                Validateは何に属する DOMAIN知識？
            そもそもDOMAINへのINPUTって何がある
                HTTP Request,CLI Input 他には?
                    いずれもTEXTデータ
                    ソケット(ストリーム)とかファイルとかもありえる？
                        でもTEXTデータ? EXCEL/TXT/CSV 
            TEXTって事で共通なのか？
                TEXTでValidate,Repositoryでpersistanceに合わせた型変換
                データ保存時に計算とか保存時刻とか、REQUESTに無いデータの作成がある
                    Repositoryで実施？
                    RepositoryはDOMAIN知識か?
                            DataMapperはpersistance側 repositoryはDOMAIN側
            入力データはTEXTなのでPOST/QUERYでText Validate
            
            型変換はPersistanceで、渡されたデータをDataMapperで加工
                POST/QUERYでINPUTの定義==>表示画面作る時の定義情報になる？

        画面の定義を１箇所にできるか？
            POST/QUERY ==> HTMLではFORM部分、あるいはJsの中？
            出力から見ると、それ以外にもデータはある
                RiotJsとかでBuild画面する場合
                    でも、これってAjaxリクエストだからPOST/QUERY
           Concertoのcontroller->BuildData() 部分は？
                これはOUTPUT(VIEWER)側に属する
                画面とは出力だから、Viewer側に属する
                    form部分はPOST/QUERYにあるから、Viewerにconstruct inject?
                そういえばsymfonyとかFormのマニュアルがあった
                という事は、viewerに取り込む?
        
        では、一体、どういう定義になるのか？
            (変数)名称(=データ)、データ型(変換ルール)
        
        例えば、mitumori.bunruiは、HTML画面上文字列(番号+名称)
            リクエストデータは、番号が文字列としてINPUTされる
            出力もTEXTで、DBデータから番号と名称を生成して出力
            Enumにしたいから、どうなる？
                入力はValidateでEnum.Valid()みたいな？
                    (new Enum($val))->validate() ==>Exception
                    それともEnum->validate($val)？
        
        では、注文主とか単純な文字列とかは？
            DataMapperとは独立して、ValidatorでValidate定義
                Validate::Text($val)?
                  現状と変わらないで良いのでは
        
        DOMAIN外にPsrRequestがあって、DOMAIN側にQUERT/POSTがある
        入力のValidateはQUERT/POSTでTEXTの判定
        
        ModelDataは、あくまでもDBカラムの定義
        RepositoryでModelDataに合わせた変換
            DbRepository、CsvRepositoryなど分かれる？
            RepositoryInterfaceの役割は＝＝＞INSERT/DELETEなどの定義
                データの変換定義ではない
            
        保存するデータの(変換)定義はどうなる？　必要？
            定義とは？　名称、データの形(datetimeではなくYYYYMMDDとか)?
            ModelDataでYYYYMMDD変換? ==>ちょっと違う
        変換はRepositoryで？
            ModelDataから自動でできないか？　Text=>Dateとかはできる
        画面からON/OFFフラグをDBに合わせて変換したい
            基本的な変換ルールはあるけど、大抵、生データをそのまま？　YYYYMMとか
        LaravelModelとかCastを持っているけど
            Action(service)でModelにrequestデータをセット
            Model内でCASTし、そのままModelsクラスで保存
        POSTから、(Laravel)ModelClassにmapingし、repositoryへ
            (Laravel)ModelClassで保存するデータの形を整える？
                    なにがある？
                    WfFreeのJsonデータとか？
                    DateTimeは、画面の作り(客先)が変わっても、
                        保存時の型をYYYYMMDDとか、システムで変化させないとか？
            RepositoryでModelDataに、さらにmapping？
                大変だけど、改造には強そう 本来のrepositoryパターンの考え方って事？
        
        no_cyuなどのValidateルールは１箇所に決めたい
        それを色々な画面のValidateで使いたい
        ModelData(DB)ではなく、(Laravel)ModelClassで定義？
            それをPOSTとかModelDataでValidate使う?
                ModelData->validateは、あくまでもDBデータとしてのvalidate
                        intとか、型変換しかない
                        Validateは、(Laravel)ModelClassで？
            でも、MstTantoの全データ保存と、一部保存でModelが違う
        Validateルールは、別途、別クラス？
            no_cyuとか、共通ぽいもものと、注文主とかって、同列で扱えるか？
                そもそも、どのようにno_cyuとかnm_syohinとかグループ化するの?
            ==>全データ保存のオブジェクトモデルを考える?
                そもそも、オブジェクトモデルは、何を基準に考えるものなのか？
                やはり、保存データになる？
        ModelDbは、保存がDBやCSVで変わるけど、保存データは変える必要は無い？
            DBだとデータ型があるけど、他はどうなる(CSVとかEXCELとか)
            EXCELはDBとは異なる型(日付とかyyyy/mm/dd DBはyyyy-mm-dd)
            その変換は、どこで？　(Laravel)ModelClass？ Repository？
                Repositoryで(Laravel)ModelClassからModelDataに？
            
        ..なにかループしている
        
        Persistance(永続化)とは、何がある DB,FILE(CSV,EXCEL)、あとは？
            MongoDbなどkey-val(DBと同じ)
            memcacheとかのcache(DB/FILEと同じ)　(永続化と考えた場合)    
            他のサーバ(送信するから、永続化と言っても、requestを投げるから、repositoryではない)
            stack(メモリ)(DB/FILEと同じ)
        
        RepositoryはDBRepository,ExcelRepositoryと別
        Repository内でデータを、DbModelData,ExcelModelDataにマッピング
            RepositoryInterfaceはinsertとかmethod定義なので無関係
        
        つまり
            DBは DBRepository, DbModelData, DbModelDb        
            EXCELは EXCELRepository, EXCELModelData, EXCELModelDb        
            マッピング,型変換作業はRepository内
            Validateは不要(POSTでOKなら通過)
            RepositoryへのデータはPOST/QUERY
                ConcertoもDispとMntDispが別だが更に分ける？
                    bumon_listとgrid_listは別の子repository
                        集計表とgrid_listは同じ子repository
                        直課計画立案データと集計表は別の子repository
            ただし、親のAggregateRepositoryにPOST/QUERYに渡す            
                QUERYの場合、grid表同じ行データは、大抵1SQLなので1repository
                たまにWf alarmなど、同時取得が厳しいと別々
            
    
20200627
    CastはReflectionNamedTypeが取得できないので、判定できないtypeがある
    
20200628
    validator
        validatorの判定は、post/queryの外で実行
        post/queryはルールのみ定義
        ルールはcontainerぽく、名前を定義して取得
        exceptionを拡張して、transitionに対応
    
    controller/service
        処理はおおよそパターン化していると思われるので、パターンを抽出する
        パターン毎にclass(HtmlQueryControllerとか)->__invoke()
        URL=>名前でdomein serviceクラスを解決
        つまり、画面個別にcontrollerを作らない
        routerでもURLで呼び出すcontrollerの切り替え処理必要
            
        現在のaaa_disp.phpならば
            query->validate
            query ==> session 記憶
            repositoryからデータ取得
            HtmlViewで画面組み立て
            HtmlResponseEmitterでPsr7Response返す
        現在のaaa_mnt.phpならば
            post->validate
            repositoryで保存
            上記HtmlViewを呼び出したい
        現在のsetEnvは?
        
    cookie/session
        domainでの処理を簡単にしたいので、objectプロパティでアクセス
        saveをどうするか
            Psr7Response　でcookieは返す
            Sessionは ajaxを考えると、書き込み直後に保存が必要

200704
    validator
        Laravel参照
        DateTime,String
        Stringは正規表現classも参照







